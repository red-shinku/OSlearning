对test.png：
	第一版本结果，在页使用数为1，2等较小的时候平均用时却远高于其他时候，并且后续曲线平稳甚至用时逐渐下降，与预期会出现的断层突增不符。可能是cache的优化导致掩盖了TLB未命中的访问代价，对于少页高耗时，推测：此时内循环对页的访问次数较少，导致clock_gettime()本身的开销格外凸显（在大量页访问时这一凸显被均摊）。于是尝试在测试TLB之前，用相同的循环测到计时函数的开销，最后从结果里面减掉。再次运行确实不再有少页面访问耗时远高于多页面的情况，（但是有新的问题，稍后第二版本说）。采用随机访问页,并且使用volatile关闭编译器优化，尝试减小cache影响。

对test2.png:
	第二版本结果。少页面的耗时计量有时会出现负数结果。查阅资料发现，现代操作系统支持cpu时钟乱序执行，也就是说，只要不存在依赖关系，那cpu会先执行花费少的语句。可能计时结果在这里被干扰。于是找到一种内存屏障的方法，让程序尽可能顺序执行（<stdatomic.h>）。然后修改代码之后效果并不明显。试着回到最简单的方面去想，clock_gettime()属于系统调用，这里陷入了操作系统，导致数十或数百纳秒的开销，因此它就不适合纳秒级别的测量?最后尝试了用cpu时钟周期的办法计时，问题依旧没有解决(不过有改善)。

test3.png、test4.png是目前最后的结果，在尝试多次后得到的好一些的表。输入测试次数为十万次。


最后一次修改，确保arr数组内存大于L3或L4缓存。
